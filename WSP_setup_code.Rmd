---
title: "WSP setup and demographics code"
author: "Lizzie Jones^[University of Brighton, l.jones4@brighton.ac.uk]"
date: "02/05/2021"
output:
  word_document: default
  pdf_document:
    number_sections: yes
  html_document:
    number_sections: yes
---


```{r setup/packages, include=FALSE, warning=FALSE}

# This code assumes that all packages are installed. If not, use 'install.packages' e.g. install.packages("likert")

# Key packages for data wrangling
wrangling <- c("dplyr","tidyverse","purr","magrittr",
             "data.table","plyr","tidyr","tibble","reshape2")
lapply(wrangling, require, character.only = TRUE) 

# Useful survey analysis packages
survey <- c("likert","careless")
lapply(survey, require, character.only = TRUE) 

# Useful packages for statistics
stats <- c("stats","ggpubr","lme4","MASS","car","psych",
                   "MuMIn","glmmTMB","nlme","DHARMa")
lapply(stats, require, character.only = TRUE) 

# Useful packages for text analysis
# text <- c("tm","tau","koRpus","lexicon","sylly","textir",
#          "textmineR","MediaNews", "lsa","SemNeT","ngram","ngramrr",
#          "corpustools","udpipe","textstem", "tidytext","text2vec")
# lapply(text, require, character.only = TRUE) 

# Favourite data visualisation packages
vismap <- c("ggvis","htmlwidgets","maps", "lattice","ggmap","ggplot2","plotly",
            "RColorBrewer", "sjPlot", "ggrepel", "rgdal", "maptools", "gpclib")
lapply(vismap, require, character.only = TRUE) 
gpclibPermit()  # Gives maptool permission to use gpclib

```
```{r working directories and data upload, include=FALSE}

# Load in working  directory and datasets
setwd("~/Documents/White-Stork-Project")

# Load in the data
original_data <- read.csv("Stork_MainDataset.csv", header = TRUE, stringsAsFactors=TRUE)
all_data <- read.csv("Stork_Dataset_Radapted.csv", header = TRUE, stringsAsFactors=TRUE)

# Two dataframes: one for each data collection (Proactive survey and Nationally representative survey) for easier comparison
proact_data <- all_data[which(all_data$SurveyType == "Proactive"),]
natrep_data <- all_data[which(all_data$SurveyType == "NatRep"),]

```



```{r create column groups for wrangling, include=FALSE}
# Assuming all packages are installed. If not use 'install.packages' e.g. install.packages("likert")


```

WSP - Initial data exploration
====================

#### About R Markdowns

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>. To generate the document of all content, click the **Knit** button. To change the output (e.g. PDF, HTML) change the 'output' at the top to any of the outputs listerd here: https://rmarkdown.rstudio.com/lesson-9.html.

## Data cleaning

First I am going to go through some data cleaning and outline any participants or data points that are removed and explain why. I am using the 'careless' pakage first to find evidence of straightlining and 


```{r data cleaning, warning=FALSE, messages=FALSE}
# Average time taken to 
# Percentiles of time 






##### Data cleaning using the 'Careless' package

# Calculates the even-odd consistency score
careless_all <- evenodd(all_data, rep(5,10))
careless_alldiag <- evenodd(all_data, rep(5,10), diag = TRUE)

# Calculates the intra-individual response variability (IRV)
# calculate the irv over all items
irv_total <- irv(all_data)
boxplot(irv_total, main="Intra-individual response variability (IRV)")
#calculate the irv over all items + calculate the irv for each quarter of the questionnaire
irv_split <- irv(all_data, split = TRUE, num.split = 4)
# boxplot(irv_split$irv4) #produce a boxplot of the IRV for the fourth quarter

# Identifies the longest string of identical consecutive responses for each observation
careless_long <- longstring(all_data, avg = FALSE)
careless_avg <- longstring(all_data, avg = TRUE)
boxplot(careless_avg$longstr, main="Number of columns in participant longstring") #produce a boxplot of the longstring index
boxplot(careless_avg$avgstr, main="Average longstring index")

# Straightlining in relation to time taken



# Find and graph Mahalanobis Distance (D) and flag potential outliers
## Need to select only numeric/integer columns
# mahad_raw <- mahad(all_data) #only the distances themselves
# mahad_flags <- mahad(all_data, flag = TRUE) #additionally flag outliers
# mahad_flags <- mahad(all_data, flag = TRUE, confidence = 0.999) #Apply a strict criterion

```


\newpage


## Exploring participant demographics

The distribution of gender and education is explored and compared between samples using stacked bar plots.

```{r demographics, echo=FALSE, warning=FALSE, message=FALSE}
# Create seperate dataframe for all demographics
all_demo <- all_data %>% select(SurveyType, Age_group, Gender, Education, Education_other,
                                Occupation, Occupation_other, Region, Area_type, Postcode, ReleaseSite)

# Explore gender percentages across both surveys
all_demo %>%
        plyr::summarise(pct.males = sum(all_demo$Gender == 'Male') / length(all_demo$Gender) * 100,
                        pct.female = sum(all_demo$Gender == 'Female') / length(all_demo$Gender) * 100,
                        pct.no_answer = sum(all_demo$Gender == 'Prefer not to answer') / length(all_demo$Gender) * 100,
                        pct.self_desc = sum(all_demo$Gender == 'Prefer to self-describe') / length(all_demo$Gender) * 100)

# Stacked barplot of gender per survey
all_gender_df<- all_demo  %>%
  group_by(SurveyType, Gender) %>%
  summarise(counts = n()) %>%
  mutate(Percentage = round(counts/sum(counts)*100, 2))

gender_bar <- ggplot(all_gender_df, aes(x = SurveyType, y = Percentage, fill = Gender)) +
  geom_col(position = position_stack(reverse = TRUE)) +
  geom_text(aes(label = paste0(Percentage, "%")),
            position = position_stack(vjust = 0.5, reverse = TRUE)) +
  scale_fill_brewer(palette = "Pastel1") +
  theme_minimal(base_size = 12) + xlab("Sample")


## Education
# Calulate percentages
all_demo %>%
        plyr::summarise(pct.furthered = sum(all_demo$Education == 'Further Education') / length(all_demo$Education) * 100,
                        pct.postgrad = sum(all_demo$Education == 'Postgraduate degree (Masters; Doctorate)') / length(all_demo$Education) * 100,
                        pct.undergrad = sum(all_demo$Education == 'Undergraduate degree') / length(all_demo$Education) * 100,
                        pct.secondary = sum(all_demo$Education == 'Secondary school (GCSEs, A Levels or equivalent)') / length(all_demo$Education) * 100,
                        pct.no_formal = sum(all_demo$Education == 'No formal qualifications') / length(all_demo$Education) * 100,
                        pct.other = sum(all_demo$Education == 'Other') / length(all_demo$Education) * 100,
                        pct.not_answer = sum(all_demo$Education == 'Prefer not to answer') / length(all_demo$Education) * 100)

# Stacked barplot of gender per survey
all_education_df<- all_demo  %>%
  group_by(SurveyType, Education) %>%
  summarise(counts = n()) %>%
  mutate(Percentage = round(counts/sum(counts)*100, 2))

levels(all_education_df$Education)[levels(all_education_df$Education)=="Secondary school (GCSEs, A Levels or equivalent)"] <- "Secondary school"
levels(all_education_df$Education)[levels(all_education_df$Education)=="Postgraduate degree (Masters; Doctorate)"] <- "Postgraduate degree"

education_bar <- ggplot(all_education_df, aes(x = SurveyType, y = Percentage,
         fill = factor(Education, levels=c("Postgraduate degree",
         "Undergraduate degree","Further Education","Secondary school",
         "No formal qualifications", "Prefer not to answer", "Other")))) +
  geom_col(position = position_stack(reverse = TRUE)) +
  geom_text(aes(label = paste0(Percentage, "%")),
            position = position_stack(vjust = 0.5, reverse = TRUE)) + # geom_text_repel
  scale_fill_brewer(palette = "Pastel1") + labs(fill = "Education", x = "Sample") +
  theme_minimal(base_size = 12)



## Occupation
# Create percentages
all_occupation_df <- all_demo  %>%
  group_by(SurveyType, Occupation) %>%
  summarise(counts = n()) %>%
  mutate(Percentage = round(counts/sum(counts)*100, 2)) # Too many levels for bar plot - see table below

```

```{r demographics - stacked plots, echo=FALSE, message=FALSE, warning=FALSE}

ggarrange(gender_bar, education_bar, ncol=1, nrow=2)

```


\newpage


### Participant demographics table

The table below (created using the package "table1") outlines the demographic characteriscs of each of the two samples, and the overall demographics of all participants across both samples. For each demographic variable the tables provides a breakdown of the number of participants within each level/group and the percentage.



```{r demographics table,echo=FALSE, message=FALSE, warning=FALSE}
# Demographics table for publication
library("table1")
both_demo <- as.data.frame(all_demo)
both_demo_data <- lapply(both_demo, function(x) x[sample(c(TRUE, NA),
                                                         prob = c(0.99999, 0.00001),size = length(x), replace = TRUE)])
# Reanme variables
levels(both_demo$SurveyType)[levels(both_demo$SurveyType)=="NatRep"] <- "Nationally rep."
levels(both_demo$Education)[levels(both_demo$Education)=="Secondary school (GCSEs, A Levels or equivalent)"] <- "Secondary school"
levels(both_demo$Education)[levels(both_demo$Education)=="Postgraduate degree (Masters; Doctorate)"] <- "Postgraduate degree"
# Reorder education factor
both_demo$Education <- factor(both_demo$Education, levels=c("Postgraduate degree",
         "Undergraduate degree","Further Education","Secondary school",
         "No formal qualifications", "Prefer not to answer", "Other"))
# Format table
table1::label(both_demo$Age_group) <- "Age group"
table1::label(both_demo$Area_type) <- "Area type"
table1::label(both_demo$ReleaseSite) <- "Release site"
# Create demo table
full_demo_table <- table1::table1(~Age_group + Gender + Education + Occupation + Region + Area_type + 
                                    ReleaseSite | SurveyType, data = both_demo)

full_demo_table

```



```{r mapping postcodes, include=FALSE}

# Download UK postcode polygon Shapefile
# download.file(
#   "http://www.opendoorlogistics.com/wp-content/uploads/Data/UK-postcode-boundaries-Jan-2015.zip",
#   "postal_shapefile"
# )
unzip("postal_shapefile")

# Read the downloaded Shapefile from disk
postal <- maptools::readShapeSpatial("./Distribution/Areas")

# Assign each "region" an unique id
postal.count <- nrow(postal@data)
postal@data$id <- 1:postal.count

# Transform SpatialPolygonsDataFrame to regular data.frame in ggplot format
postal.fort <- ggplot2::fortify(postal, region='id')

# Extract first two digits of postcode and make uppercase
all_demo$postal_area_code = toupper(substr(all_data$Postcode, 1, 2))
all_demo$postal_area_code <- gsub('[0-9]+', '', all_demo$postal_area_code)

df <- all_demo %>%
  dplyr::select(postal_area_code) %>% 
  group_by(postal_area_code) %>%
  summarise(freq = n())

# Add "region" id to frequency data
df <- merge(df, postal@data, by.x="postal_area_code", by.y="name")
# Merge frequency data onto geogrphical postal polygons
postal.fort <- merge(postal.fort,  df, by="id", all.x=T, all.y=F)
postal.fort <- postal.fort[order(postal.fort$order),] # Reordering since ggplot expect data.fram in same order as "order" column

########################################
# Read the downloaded Shapefile from disk
postcode_outcodes <- read_csv("Distribution/postcode-outcodes.csv") # linking into a folder within working directory
View(postcode_outcodes)




```

\newpage

### Participant postcode mapping 

Map so far of participant postcode (first 1 or 2 alphabetical digits, e.g. SW or N)





```{r postcode map, fig.cap = "Participant postcode mapping",fig.dim = c(10, 7), message=FALSE, echo=FALSE, warning=FALSE}

# Create a postcode map
ggplot(postal.fort) + 
  geom_polygon(aes(x = long, y = lat, group = group, fill=freq), colour='white') + 
  scale_fill_gradient2(low = "darkgreen", mid = "yellow", high = "red", midpoint = 250) +
  labs(fill = "Participant frequency", x = "Longitude", y = "Latitude") +
  
  coord_fixed()



```


